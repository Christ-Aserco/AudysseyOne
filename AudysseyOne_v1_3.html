<!-- 
  Copyright (c) [2024] [OCA - https://www.youtube.com/@OCAudiophile]

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, and to permit persons to
  whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  Redistribution and use in source and binary forms, with or without
  modification, are not permitted for commercial purposes without the explicit
  permission of the author.
-->
<!DOCTYPE html><html>
<head>
  <title>Audyssey One - OCA 2024</title>
  <style>
    body {font-family: Arial, sans-serif;background-color: #f2f2f2;}
    .container {max-width: 1080px;margin: 0 auto;padding: 20px;}
    h2 {
      text-align: center;
      font-size: 24px;
      margin-bottom: 20px;
      color: #fff;
      background-color: #6fa3e7;
      padding: 10px 20px;
      border-radius: 10px;
    }
    strong {font-style: italic;}
    ol {padding-left: 20px;}
    .button-container {display: flex;justify-content: flex-start;margin-bottom: 20px;}
    button {
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 30px;
      border: none;
      color: #fff;
      background-color: #6fa3e7;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      cursor: pointer;
      width: 200px;
    }
      button:hover {background-color: #4c6cb3;}
      button:disabled {opacity: 0.5;cursor: not-allowed;}
    #fileInput {display: none;}
    #logContainer {
      background-color: #333;
      color: #fff;
      padding: 10px;
      border-radius: 5px;
      max-height: 400px; /* Adjust the height as needed */
      overflow-y: auto; /* Add scrollbar if log exceeds max-height */
    }
    h2.log-heading {
      font-family: Arial, sans-serif;
      font-size: 16px; /* Adjust the font size as needed */
      text-indent: 5px; /* Adjust the left indent value as needed */
      margin-bottom: 5px; /* Adjust the bottom margin as needed */
      width: 120px;
      background-color: #808080;
      color: #fff;
    }
  </style>
</head>
<body>
<div class="container">
    <h2><strong>1-click</strong> Audyssey Optimization</h2>
    <ol>
      <li>Download and install the latest REW beta version (v5.40 Beta 18 or above) from <a href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>.</li>
      <li>Remove any existing microphone calibration file from REW (Navigate to Preferences, then go to the "Cal files" tab).</li>
      <li>Under Preferences, set REW's "Maximum measurements" to 300 (This requires restarting REW).</li>
      <li>Click the "Upload" button below to select and save the Audyssey calibration file (extension: '.ady') transferred from your MultEQ Editor app.</li>
    </ol>
    <input type="file" id="fileInput" accept=".ady" onchange="handle_adyUpload(event)">
    <div class="button-container">
      <button id="button1" onclick="document.getElementById('fileInput').click()">Upload</button>
    </div>
    <ol start="5">
      <li>When prompted, save the target curve file "DrTooleTargetCurve.txt" and the zipped measurements file in a folder on your computer.</li>
      <li>In REW, navigate to the "EQ" tab, then House Curve, and select "DrTooleTargetCurve.txt" you saved earlier.</li>
      <li>Open the zip file (no need to extract it), select all files (CTRL+A for Windows, command+C for Mac), and drag and drop them onto REW.</li>
      <li>All Audyssey measurements will be automatically imported in the correct order; do not change their orders or names.</li>
      <li>Start REW API server (navigate to API tab under Preferences and click 'Start server').</li>
      <li>For better performance, keep REW on "SPL & Phase" tab, untick "Animate measurement list" in Preferences/View and close all REW child windows.</li>
      <li>Please allow your CPU fans to cool down after importing measurements into REW before proceeding to click the button below.</li>
    </ol>
    <div class="button-container">
      <button id="button2" onclick="startButton_clicked()" disabled>Start Optimization</button>
    </div>
    <br>
    <h2 class="log-heading">System Log:</h2>
        <pre id="logContainer"></pre>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script>
// **************************** version 1.3 03 APR 2024 - 22:00 CET ************************************
  let adyContents; let fileName;
  let dChannels; let subtrueMaxDelay;let subtrueMaxTrim;
  let indexSW; let cDist; let invertSub = 0;
  let sOs;
  let delay = 150; //increase this value if your machine is slow and needs more time to process operations
  const baseUrl = 'http://localhost:4735/measurements';
  const pollUrl = 'http://localhost:4735/measurements/process-result';
  let averageLvl;

  function checkModelSpeedOfSound(jsonData) {
    const targetModelName = jsonData.targetModelName;
    const lastSixDigits = targetModelName.slice(-6);
    const specialModels = [

                    //Add your model name in the list below if you're certain your receiver's speed of sound setting is 300 m/s.

                    "X1300W", "X2300W", "X3300W", "X4300H", "X6300H",
                    "X1400H", "X2400H", "X3400H", "X4400H", "X6400H",
                    "X1500H", "X2500H", "X3500H", "X4500H", "X6500H", "X8500H",
                    "X1600H", "X2600H", "X3600H",
                    "X1700H", "X2700H", "X3700H", "X4700H","X6700H",

                    "SR5011", "SR6011", "SR7011",
                    "SR5012", "SR6012", "SR7012", "SR8012",
                    "SR5013", "SR6013", "SR7013",
                    "SR5014", "SR6014", 
                    "SR5015", "SR6015", "SR7015", "SR8015",
                    "AV7703", "AV7704", "AV7705", "AV7706", "AV8805",
                    "NR1607", "NR1608", "NR1711"

                    ];

    const isSpecialModel = specialModels.includes(lastSixDigits);
    (isSpecialModel ? sOs = 300.0 : sOs = 343.0);
    return targetModelName;
  }
  async function updateConstants(jsonData) {
    let nSubs = 0;
    const channelKeys = Object.keys(jsonData.detectedChannels);
    dChannels = channelKeys.length;
    for (let i = dChannels; i >= 1; i--) {
      const key = channelKeys[i - 1];
      const commandId = jsonData.detectedChannels[key].commandId;
      if (commandId.startsWith("SW")) {
        nSubs++;
      } else {
        dChannels -= nSubs; dChannels++; break;
      }
    }
    if (nSubs === 0) {throw new Error('Optimization will not work with systems with NO subwoofer!')}
    subtrueMaxDelay = 0.0;
    subtrueMaxTrim = 0.0;
    if (nSubs > 1) {
        for (let i = dChannels - 1; i < Object.keys(jsonData.detectedChannels).length; i++) {
                const delayAdjustment = parseFloat(jsonData.detectedChannels[i].delayAdjustment);
                const trimAdjustment = parseFloat(jsonData.detectedChannels[i].trimAdjustment);
                if (delayAdjustment > subtrueMaxDelay) {subtrueMaxDelay = delayAdjustment;}
                if (trimAdjustment < subtrueMaxTrim) {subtrueMaxTrim = trimAdjustment;}
              }
    }
    subtrueMaxDelay = 6.0 - subtrueMaxDelay;
    subtrueMaxTrim = -(12.0 + subtrueMaxTrim) / 2;
    cDist = parseFloat(jsonData.detectedChannels[1].customDistance);
    if (!cDist > 0.0) {cDist = parseFloat(jsonData.detectedChannels[1].channelReport.distance);}

        if (cDist === 0) {
          const result = await swal.fire({
            confirmButtonColor: "#6fa3e7",
            text: "Audyssey was not able to save your speaker distances to file because it decided your subwoofer required a delay beyond the limits. You will need to manually enter distance of the center speaker to the main listening position to continue(in meters):",
            input: 'text',
            showCancelButton: true
          });

            if (result.isConfirmed) {
              const userInput = result.value;
              cDist = parseFloat(userInput);
              console.info(`Center speaker actual distance is set at ${cDist}m based on user input.`);
            }
          
    } 
  }
  function handle_adyUpload(event) {
    document.getElementById("button2").disabled = false;
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
      adyContents = e.target.result;
      const jsonData = JSON.parse(adyContents);
      const zip = new JSZip();
      for (const key in jsonData.detectedChannels) {
        if (jsonData.detectedChannels.hasOwnProperty(key)) {
          const responseData = jsonData.detectedChannels[key].responseData;
          for (const arrayKey in responseData) {
            if (responseData.hasOwnProperty(arrayKey)) {
             const arrayData = responseData[arrayKey].join('\n');
              const rewHeader = "* Impulse Response data saved by REW\n0 // Peak value before normalisation\n0 // Peak index\n16384 // Response length\n2.0833333333333333E-5 // Sample interval (seconds)\n0.0 // Start time (seconds)\n* Data start\n" + arrayData;
              var measurementName = jsonData.detectedChannels[key].commandId + arrayKey + '.txt';
              zip.file(measurementName, rewHeader);
            }
          }
        }
      }
      zip.generateAsync({type: "blob"}).then(function (content) {
        const urlZip = URL.createObjectURL(content);
        var downloadLink = document.createElement("a");
        downloadLink.href = urlZip;
        fileName = file.name;
        downloadLink.download = getadyName(file.name, "_extractedMeasurements.zip");
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      });
      const targetCurve = `
      6.3 2.357,
      6.7 2.357,
      7.1 2.357,
      7.5 2.357,
      8 2.357,
      8.5 2.357,
      9 2.357,
      9.5 2.357,
      10 2.357,
      10.6 2.357,
      11.2 2.357,
      11.8 2.357,
      12.5 2.357,
      13.2 2.357,
      14 2.357,
      15 2.357,
      16 2.357,
      17 2.357,
      18 2.357,
      19 2.356,
      20 2.354,
      21.2 2.35,
      22.4 2.343,
      23.6 2.336,
      25 2.328,
      26.5 2.32,
      28 2.311,
      30 2.3,
      31.5 2.292,
      33.5 2.282,
      35.5 2.273,
      37.5 2.263,
      40 2.253,
      42.5 2.242,
      45 2.231,
      47.5 2.221,
      50 2.21,
      53 2.197,
      56 2.183,
      60 2.162,
      63 2.144,
      67 2.119,
      71 2.092,
      75 2.065,
      80 2.028,
      85 1.99,
      90 1.952,
      95 1.912,
      100 1.87,
      106 1.815,
      112 1.76,
      118 1.706,
      125 1.648,
      132 1.592,
      140 1.531,
      150 1.461,
      160 1.395,
      170 1.333,
      180 1.274,
      190 1.219,
      200 1.167,
      212 1.107,
      224 1.051,
      236 0.998,
      250 0.939,
      265 0.88,
      280 0.824,
      300 0.754,
      315 0.704,
      335 0.641,
      355 0.582,
      375 0.526,
      400 0.461,
      425 0.399,
      450 0.341,
      475 0.287,
      500 0.235,
      530 0.176,
      560 0.12,
      600 0.05,
      630 0.001,
      670 -0.062,
      710 -0.12,
      750 -0.175,
      800 -0.24,
      850 -0.3,
      900 -0.358,
      950 -0.412,
      1000 -0.464,
      1060 -0.521,
      1120 -0.575,
      1180 -0.627,
      1250 -0.683,
      1320 -0.737,
      1400 -0.794,
      1500 -0.86,
      1600 -0.92,
      1700 -0.972,
      1800 -1.014,
      1900 -1.042,
      2000 -1.057,
      2120 -1.066,
      2240 -1.069,
      2360 -1.072,
      2500 -1.075,
      2650 -1.079,
      2800 -1.082,
      3000 -1.083,
      3150 -1.084,
      3350 -1.084,
      3550 -1.085,
      3750 -1.086,
      4000 -1.091,
      4250 -1.099,
      4500 -1.111,
      4750 -1.132,
      5000 -1.159,
      5300 -1.198,
      5600 -1.239,
      6000 -1.291,
      6300 -1.329,
      6700 -1.377,
      7100 -1.422,
      7500 -1.464,
      8000 -1.511,
      8500 -1.55,
      9000 -1.577,
      9500 -1.594,
      10000 -1.606,
      10600 -1.616,
      11200 -1.62,
      11800 -1.622,
      12500 -1.622,
      13200 -1.623,
      14000 -1.623,
      15000 -1.622,
      16000 -1.621,
      17000 -1.619,
      18000 -1.615,
      19000 -1.612,
      20000 -1.61,
      21200 -1.609,
      22400 -1.609,
      23600 -1.609`;
      const blob = new Blob([targetCurve], {type: 'text/plain'});
      const urlBlob = URL.createObjectURL(blob);
      var downloadLink = document.createElement("a");
      downloadLink.href = urlBlob;
      downloadLink.download = "DrTooleTargetCurve.txt"; 
      downloadLink.style.display = "none";
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    };
    reader.readAsText(file);
  }
  function getadyName(fileName, suffix) {
    var dotIndex = fileName.lastIndexOf(".");
    var modifiedName = fileName.substring(0, dotIndex) + suffix;
  return modifiedName;
  }
  function startButton_clicked() {
    document.getElementById('button1').disabled = true;
    optimizerOCA();
  }
  async function fetch_mREW(indice = null, method = 'GET', _body = null){
      let body;
      let requestUrl;
      if (indice === null) {requestUrl = baseUrl;} else {requestUrl = baseUrl + `/${indice}`};
      if (method === 'PUT') {body = _body}
      while(true) {
          try {
              const response = await fetch(requestUrl,{
                method: method,
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body)
                });
              if (!response.ok) {
                  await new Promise(resolve => setTimeout(resolve, delay)); 
                  } else {const data = await response.json();
                          return data;}
                   
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postNext(processName, indices, parameters = null) {
      let requestUrl; let body;
      if (Array.isArray(indices)) {requestUrl = `${baseUrl}/process-measurements`}
          else {(parameters === null ? requestUrl = `${baseUrl}/${indices}/eq/command` : requestUrl = `${baseUrl}/${indices}/command`)};
      if (requestUrl.endsWith('/command')) {body = {command: processName}}
          else body = {processName: processName};
      if (parameters != null) {body = { ...body, parameters: parameters}};
      if (Array.isArray(indices)) {body = { ...body, measurementIndices: indices}};
          await fetch(requestUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
          });
      const object = await pollComplete(processName);
      return object;
  }
  async function pollComplete(processName) {
      while(true) {
          try {
              const response = await fetch(pollUrl);
              if (!response.ok) {
                  throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === "Completed" && data.processName === processName) {
                  return data;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postSafe(requestUrl, parameters) {
      while(true) {
          try {
              const response = await fetch(requestUrl,{
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(parameters)
              });
              if (!response.ok) {
                  throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === "Update processed") {
                  return data;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postDelete(indice) {
      const mDeleted = `Measurement ${indice} deleted`
      while(true) {
          try {
              const response = await fetch(`${baseUrl}/${indice}`,{
                method: 'DELETE',
                headers: {'Content-Type': 'application/json'},
                });
              if (!response.ok) {
                   throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === mDeleted) {
                  return indice;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      //delay--;
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              //delay++;
              await new Promise(resolve => setTimeout(resolve, delay)); 
              }
      }
  }
  async function fetchSafe(extUrl, indice, parameters = null) {
    const requestUrl = `${baseUrl}/${indice}/${extUrl}`;
    let options;
    if (parameters === null) {
      options = {
        method: 'GET'
      };
    } else {
      options = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(parameters)
      };
    }
    while (true) {
      try {
        const response = await fetch(requestUrl, options);
        if (!response.ok) {
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          const data = await response.json();
          return data;
        }
      } catch (error) {
        console.error('Error fetching result:', error);
      }
    }
  }
  async function check_initialConditions() {
    
    const measurements = await fetch_mREW();
    const titles = {};
    let titleIndices = {};
    const mCount = Object.keys(measurements).length
    for (let i = 1; i <= mCount; i++) {
      const title = measurements[i].title;
      const titleKey = title.replace(/\d+/g, '');
      if (!/^\D+(\d+)?$/.test(titleKey)) {
        throw new Error(`Speaker name ${titleKey} does not end with an indice.`);
      }
      if (!titles[titleKey]) {
        titles[titleKey] = true;
        titleIndices[titleKey] = [];
      }
      const matchResult = title.match(/\d+/);
      if (matchResult && matchResult.length > 0) {
        titleIndices[titleKey].push(parseInt(matchResult[0]));
      } else {
        throw new Error(`No indices found in speaker name: ${title}`);
      }
    }
    nSpeakers = Object.keys(titles).length;
    const indicesCounts = Object.values(titleIndices).map(indices => indices.length);
    const isIndicesEqual = indicesCounts.every(count => count === indicesCounts[0]);
    if (!isIndicesEqual) {
      throw new Error('Speaker names have different numbers of indices.');
    }
    for (const titleKey in titleIndices) {
      const indices = titleIndices[titleKey];
      const sortedIndices = [...indices].sort((a, b) => a - b);
      if (JSON.stringify(indices) !== JSON.stringify(sortedIndices)) {
        throw new Error(`Indices of ${titleKey} are not in order.`);
      }
    }
    const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
    if (tcResponse.ok) {
      const tcPath = await tcResponse.json();
      if (tcPath && tcPath.message) {
        console.log(`Applying Target Curve located @ ${tcPath.message}`);
      } else {
        throw new Error('Failed to locate target curve! Browse to and select "DrTooleTargetCurve.txt" in "REW / EQ window / House curve.');
      }
    } else {
      throw new Error(`Failed to fetch target curve, please start the API server! HTTP status code: ${tcResponse.status}.`);
    }
    return (nSpeakers);
  }
  async function getVectorAverages() {
    const measurements = await fetch_mREW();
    const mCount = Object.keys(measurements).length
    const micPositions = mCount / dChannels;
    console.log(`Transposing measurements from '${micPositions}' different microphone positions to the primary listening position...`);
    for (let i = 1; i <= mCount; i+= micPositions) {
      const indices = Array.from({length: micPositions}, (_, j) => i + j);
      await postNext('Cross corr align', indices);
      await postNext('Vector average', indices);
      const tIndex = mCount + 1 + (i - 1) / micPositions;
      const newTitle = measurements[i].title.slice(0,-1) + "o";
      await fetch_mREW(tIndex, 'PUT', {title: newTitle});
    };
    console.info(`Done!`);
    console.info(`************************************************************************************************************************`);
    console.info(`Cleaning up processed measurements...`);
    for (let i = mCount; i > 0; i--) {
      await postDelete(i);
      await new Promise(resolve => setTimeout(resolve, delay * 1.15)); }
      console.log(`Done!`);
      console.info(`************************************************************************************************************************`);
  }
  async function alignLevels() {
    let customLevel = new Array(dChannels + 1).fill(0);
    let targetSum = 0;
    let target = {};
    let title = {};
    indexSW = 1;
    console.log('Calculating precise speaker volume levels...');
    for (let i = 1; i <= dChannels; i++) {
      await postNext('Add SPL offset', i, {offset: -42});
      const mData = await fetch_mREW(i);
      title[i] = mData.title;
      await postSafe(`${baseUrl}/${i}/target-settings`, { shape: "None" });
      await postSafe(`${baseUrl}/${i}/room-curve-settings`, { addRoomCurve: false });
      if (title[i].startsWith("SW")) {indexSW = i; continue;}
      await postNext('Smooth', i, {smoothing: "1/1"});
      await postNext('Calculate target level', i);
      await postNext('Smooth', i, {smoothing: "None"});
      const targetResponse = await fetchSafe('target-level',i);
      target[i]= parseFloat(targetResponse);
      console.log(`${title[i]}: ${target[i]} dB`);
      targetSum += target[i];
    }
    averageLvl = parseFloat(targetSum / (dChannels - 1.0));
    console.info(`Optimized target volume level for all speakers: ${averageLvl} dB`);
    console.info(`Total number of speakers averaged (excludes subwoofer): ${dChannels - 1}`);
    console.log('Finalized speaker volume settings:');
    for (let i = 1; i <= dChannels; i++) {
      if (i === indexSW) {
        console.info(`Optimizing subwoofer volume adjustment...`);
        await fetchSafe('target-level',i, averageLvl);
        await postNext('Generate target measurement', indexSW);
        const indexTC = dChannels + 1;
        const volShift = await postNext('Align SPL', [indexSW, indexTC], {"frequencyHz": "80","spanOctaves": "3","targetdB": "average"});
        const volDelta = parseFloat(volShift.results[indexSW].alignSPLOffsetdB);
        let volDeltaNew = volDelta;
        if ((volDelta > 6.0) || (volDelta < subtrueMaxTrim)) {
          console.error(`Required subwoofer volume adjustment is beyond AV Receiver's hardware limits!`);
          console.warn(`Be advised to repeat Audyssey calibration process after re-adjusting subwoofer volume!`);
          console.info(`The algorithm will now apply maximum possible volume setting to the subwoofer and continue.`);
          console.warn("However, optimization will not result in the best achiveable performance!");
          volDeltaNew = Math.max(subtrueMaxTrim, Math.min(12, volDelta));
        }
        customLevel[i] = (Math.round(volDeltaNew * 4) / 2).toFixed(1);
        console.log(`${title[indexSW].slice(0,-1)}: ${customLevel[i]} dB ; with ${volDeltaNew * 2 - customLevel[i]} dB filter compensation`);
        await postNext('Add SPL offset', indexSW, {offset: volDeltaNew});
        await postNext('Add SPL offset', indexTC, {offset: volDeltaNew});
        continue;
      }
    const volDif = parseFloat(averageLvl - target[i]);
    let volDifNew = volDif;
    if ((volDif > 12.0) || (volDif < -12.0)) {
      console.error(`${title[i].slice(0,-1)} seems to require volume adjustment beyond AV Receiver's hardware limits!`);
      console.warn(`Be advised to find the root cause of this problem and repeat Audyssey calibration if possible!`);
      console.info(`Optimization will now apply maximum possible volume setting to ${title[i].slice(0,-1)} and continue.`);
      console.warn("However, the optimization 'may' not result in the best achiveable performance!");
      volDifNew = Math.max(-12, Math.min(12, volDif));
    }
    customLevel[i] = (Math.round(volDifNew * 2) / 2).toFixed(1);
    console.log(`${title[i].slice(0,-1)}: ${customLevel[i]} ; with ${volDifNew - customLevel[i]} dB filter compensation`)
    await postNext('Add SPL offset', i, {offset: customLevel[i]});
    }
    console.info(`************************************************************************************************************************`);
    return customLevel;
  }
  async function alignDelays() {
  console.info('Deriving optimal speaker distances with advanced cross-correlation analysis...');
  let customDistance = new Array(dChannels + 1).fill(0);
  const minDelay = parseFloat(6.0 / sOs);
  let mDist = {};
  let mSec = {};
  var minSec = cDist / sOs;
  const indices = Array.from({ length: dChannels }, (_, index) => index + 1);
  const mDelay = await postNext('Cross corr align', indices);
  const measurements = await fetch_mREW();
  for (let i = 1; i <= dChannels; i++) {
    mSec[i] = parseFloat(mDelay.results[i][`Adjustment (seconds)`]);
    customDistance[i] = Number((cDist + (mSec[i] * sOs)).toFixed(2));
    if (mSec[i] < minSec) {
      minSec = mSec[i];
    }
    console.log(`${measurements[i].title.slice(0, -1)}: ${customDistance[i]}m`);
  }
  let minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
  let minChk = Number(minChk_val.toFixed(2));
  let finDist_val = cDist + minSec * sOs + minChk;
  customDistance[indexSW] = Number(finDist_val.toFixed(2));
  if (minChk <= subtrueMaxDelay) {
    console.info(`Subwoofer distance is 'optimally' set @ ${customDistance[indexSW]}m and is 'safely' within the AV Receiver's speaker spacing limits.`);
  } else {
    console.warn(`Calculated optimal subwoofer distance of ${customDistance[indexSW]}m exceeds AV Receiver's max. speaker spacing limit [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m]!`);
    console.info('Attempting to re-align the sub...');
    await postNext('Remove IR delays', [1, indexSW]);
    await postNext('Remove IR delays', [1, indexSW]);
    await postNext('Remove IR delays', [1, indexSW]);
    const resultC = await fetch_mREW(1);
    const resultSW = await fetch_mREW(indexSW);
    mSec[1] = parseFloat(resultC.cumulativeIRShiftSeconds);
    mSec[indexSW] = parseFloat(resultSW.cumulativeIRShiftSeconds);
    minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
    minChk = Number(minChk_val.toFixed(2));
    finDist_val = cDist + minSec * sOs + minChk;
    customDistance[indexSW] = Number(finDist_val.toFixed(2));
    if (minChk <= subtrueMaxDelay) {
      console.info(`Subwoofer distance is re-set to ${customDistance[indexSW]}m and is now within receiver speaker spacing limits [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m].`);
    } else {
      console.warn(`Recalculated subwoofer distance of ${customDistance[indexSW]}m still exceeds AV Receiver's max. speaker spacing limit [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m]!`);
      console.info('Attempting to re-align the sub...');
      await postNext('Align IR start', [1, indexSW]);
      await postNext('Align IR start', [1, indexSW]);
      const resultC = await fetch_mREW(1);
      const resultSW = await fetch_mREW(indexSW);
      mSec[1] = parseFloat(resultC.cumulativeIRShiftSeconds);
      mSec[indexSW] = parseFloat(resultSW.cumulativeIRShiftSeconds);
      minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
      minChk = Number(minChk_val.toFixed(2));
      finDist_val = cDist + minSec * sOs + minChk;
      customDistance[indexSW] = Number(finDist_val.toFixed(2));
      if (minChk <= subtrueMaxDelay) {
        console.info(`Subwoofer distance is again re-set to ${customDistance[indexSW]}m and is finally within the receiver speaker spacing limits [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m].`);
      } else {
        console.warn(`Recalculated subwoofer distance of ${customDistance[indexSW]}m still exceeds AV Receiver's max. speaker spacing limit [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m]!`);
        customDistance[indexSW] = Number((subtrueMaxDelay + cDist + minSec * sOs).toFixed(2));
        console.info(`Setting subwoofer distance 'suboptimally' to ${customDistance[indexSW]}m (max. allowed).`);
        console.warn("Please ensure to inspect your setup thoroughly to identify the root cause of the significant delay!")
        const maxsubDelay = (minChk - subtrueMaxDelay) / sOs;
        await postNext('Offset t=0', indexSW, {offset: maxsubDelay, unit: "seconds"});
      }
    }
  }
  const indicesbarSW = indices.filter(index => index !== indexSW);
  await postNext('Cross corr align', indicesbarSW);
  console.info(`************************************************************************************************************************`);
  return customDistance;
  }
  async function generateFilters() {
    console.info(`Crafting custom room correction filters...`);
    delay *= 2;
    const measurements = await fetch_mREW();
    let indexTC = dChannels + 1;
    await postNext('Minimum phase version', indexTC, {
      "include cal": false,
      "append lf tail": false, 
      "append hf tail": false,
      "frequency warping": false,
      "replicate data": false
    });
    await postDelete(indexTC);
    await fetch_mREW(indexTC,'PUT', {title: "Dr Toole target curve"});
    await new Promise(resolve => setTimeout(resolve, delay * 1.15));
    for (let i = 1; i <= dChannels; i++) 
    {
      await postNext('Minimum phase version', i, {
        "include cal": false,
        "append lf tail": false, 
        "append hf tail": false,
        "frequency warping": false,
        "replicate data": false
      });
      ii = dChannels + i * 2;
      
      await postNext('Arithmetic', [ii, indexTC], {
        function: "A / B",
        regularisation: "0",
        lowerLimit: "0",
        upperLimit: "0"});
      await postNext('Arithmetic', [ii + 1, ii + 1], {
        function: "1 / A",
        maxGain: "0",
        lowerLimit: "0",
        upperLimit: "200",
        autoTarget: "0",
        excludeNotches: false});
      await postNext('Minimum phase version', ii + 2, {
        "include cal": false,
        "append lf tail": false, 
        "append hf tail": false,
        "frequency warping": false,
        "replicate data": false
      });
      await postNext('Arithmetic', [i, ii + 3], {function: "A * B"});
      const finTitle = measurements[i].title.replace("o","final");
      await fetch_mREW(ii + 4, 'PUT', {title: finTitle});
      const filtTitle = measurements[i].title.replace("o","");
      await fetch_mREW(ii + 3, 'PUT', {title: filtTitle});
      console.log(`Optimal filter generation for speaker ${filtTitle} is completed.`);


      await postDelete(ii);
      await new Promise(resolve => setTimeout(resolve, delay * 1.15));
      await postDelete(ii);
      await new Promise(resolve => setTimeout(resolve, delay * 1.15));
      await postDelete(ii);
      await new Promise(resolve => setTimeout(resolve, delay * 1.15));


    }
    console.log(`Done!`);
    console.info(`************************************************************************************************************************`);
  }
  async function calculateCrossovers() {
      console.info(`Pinpointing crossover frequencies for each speaker...`);
      let customCrossover = new Array(dChannels + 1).fill(0);
      let newMeasurements;
      delay *= 1.5;
      const level = averageLvl;
      const measurements = await fetch_mREW();
      const indexSWf = dChannels + indexSW * 2 + 1;
      const indexTC = dChannels + 1;
      const start = dChannels + 3;
      const end = dChannels * 3 + 1;
      newMeasurements = await fetch_mREW();
      const magDr = await fetchSafe('frequency-response', dChannels + 1);
      const bytesDr = Uint8Array.from(atob(magDr.magnitude), c => c.charCodeAt(0));
      const bufferDr = bytesDr.buffer;
      const dataDr = new DataView(bufferDr);  
      const phaseArray = [];     
      const phaseSW = await fetchSafe('frequency-response', indexSWf);
      const bytesSW = Uint8Array.from(atob(phaseSW.phase), c => c.charCodeAt(0));
      const bufferSW = bytesSW.buffer;
      const dataSW = new DataView(bufferSW);  
      for (var j = 0; j < 702; j++) {
        const swPhase = dataSW.getFloat32(j * 4);
        phaseArray.push(swPhase);
        }
      const freqIndex = [40, 60, 80, 90, 100, 110, 120, 150, 180, 200, 250];
      const phaseIndex = [102, 157, 211, 239, 266, 293, 321, 403, 485, 539, 676]
      let k=1;
      for (let i = start; i <= end; i += 2) {
        const magSpeaker = await fetchSafe('frequency-response', i);
        const bytes = Uint8Array.from(atob(magSpeaker.magnitude), c => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const dataSP = new DataView(buffer);  
        for (j = 20; j < 702; j++) {
          const speakerMag = dataSP.getFloat32(j * 4);
          const drMag = dataDr.getFloat32(j * 4);
          if (speakerMag > drMag) {break;}
        }
       
        if (j > 701) {throw new Error("Speaker's bass response is below target throughout the range! This error may indicate a buggy MultEQ Editor app version measuring extremely high subwoofer volumes. If that's the case you will need to install a different version of the app and repeat Audyssey calibration. Rarely, this error may have also been caused by open baffle or Atmos enabled upfiring speakers.");}
        const xoFreq = j * 0.366211 + 2.563477;
        let roundedXoFreq;
        let minDiff = Infinity;
        for (const value of freqIndex) {
          const diff = Math.abs(xoFreq - value);
          if (diff < minDiff) {
            minDiff = diff;
            roundedXoFreq = value;
          }
        }
        const phaseSpeaker = await fetchSafe('frequency-response', i);
        const bytesSP = Uint8Array.from(atob(phaseSpeaker.phase), c => c.charCodeAt(0));
        const bufferSP = bytesSP.buffer;
        const phasedataSP = new DataView(bufferSP);  
        j = phaseIndex[freqIndex.indexOf(roundedXoFreq)];
        let phaseDif = phasedataSP.getFloat32(j * 4) - phaseArray[j];


        if (phaseDif > 180) {phaseDif -= 360}
          else {if (phaseDif < -180) {phaseDif += 360}};
        
        i_phaseDif = phaseDif + 180;
        if (i_phaseDif > 180) {i_phaseDif -= 360}
          else {if (i_phaseDif < -180) {i_phaseDif += 360}};

        const phaseDelay = phaseDif / 360 / roundedXoFreq * 1000;
        const i_phaseDelay = i_phaseDif / 260 /roundedXoFreq * 1000;

        if ((newMeasurements[i].title.slice(0,-5) === 'FL') && (math.abs(i_phaseDelay) < math.abs(phaseDelay))) {invertSub++};
        if ((newMeasurements[i].title.slice(0,-5) === 'FR') && (math.abs(i_phaseDelay) < math.abs(phaseDelay))) {invertSub++};


        if (i === indexSWf) {console.log(`Subwoofer measures flat down to ${xoFreq.toFixed(5)}Hz!`)}
          else {console.log(`Optimal crossover frequency for speaker ${newMeasurements[i].title.slice(0,-5)}: ${xoFreq.toFixed(5)}Hz, closest receiver XO freq: ${roundedXoFreq}Hz`);
          console.log(`- @ ${roundedXoFreq}Hz - phase difference with SW: ${phaseDif.toFixed(2)} degrees, phase delay: ${phaseDelay.toFixed(2)} ms`)};
        if (roundedXoFreq < 80) {roundedXoFreq = 80};
        customCrossover[k] = String(roundedXoFreq).slice(0, 2);
        k++;
      }
      console.info(`Done!`);
      if (invertSub === 2) {
        console.info(`***************************************************************************************************`);
        console.info(`Your SUBWOOFER's POLARITY as detected by Audyssey has been INVERTED by A1 for better bass response!`);
        console.info(`***************************************************************************************************`);
      }
      console.info(`All crossover frequencies below 80Hz were set to 80Hz to reduce the workload on the amplifier and speaker drivers for improved clarity.`);
      console.info(`Feel free to lower the crossover frequencies if you're using power amplifiers or high-sensitivity speakers, but be cautious to remain above the calculated frequencies shown above.`);
      console.info(`For speaker pairs with different crossover frequencies, the AV receiver will synchronize them to the lower frequency of the two.`);
      console.info(`***********************************************************************************************************************************`);
    return customCrossover;
  }
  async function updateADY(customLevel, customDistance, customCrossover){
    console.info(`Uploading all optimization adjustments into the final calibration file...`);
    let filterTitle = {};
    const jsonData = JSON.parse(adyContents);
    jsonData.dynamicVolume=false;
    jsonData.lfc=false;
    jsonData.dynamicEq=false;
    jsonData.enTargetCurveType = 1;

    for (const key in jsonData.detectedChannels) {
      if (jsonData.detectedChannels.hasOwnProperty(key)) {
        const responseData = jsonData.detectedChannels[key].responseData;
        for (const arrayKey in responseData) {
          if (responseData.hasOwnProperty(arrayKey)) {
            const zerosArray = Array(16383).fill("0");
            zerosArray.unshift("1");
            responseData[arrayKey] = zerosArray;
          }
        }
      }
    }
    const start = dChannels + 2;
    const end = dChannels * 3;
    for (let i = start; i <= end; i += 2) {
      const mData = await fetch_mREW(i);
      filterTitle[i] = mData.title;
      const fetchedData = await fetchSafe('frequency-response',i);
      const magBase64 = fetchedData.magnitude;
      const startFreq = fetchedData.startFreq;
      const freqStep = fetchedData.freqStep;
      const bytes = Uint8Array.from(atob(magBase64), c => c.charCodeAt(0));
      const buffer = bytes.buffer;
      const floatArray = new Float32Array(buffer);
      const dataView = new DataView(buffer);
      for (let i = 0; i < floatArray.length; i++) {floatArray[i] = dataView.getFloat32(i * 4);}
      const firstColumn = new Float32Array(floatArray.length);
      for (let i = 0; i < firstColumn.length; i++) {firstColumn[i] = startFreq + i * freqStep;}
      const decodedData = new Array(floatArray.length);
      for (let i = 0; i < decodedData.length; i++) {decodedData[i] = [firstColumn[i], floatArray[i]];}
      const additionalRows = [//anti HFR1 new version
                              [3003.389648,0.009],
                              [3025.153448,0.009],
                              [3047.074957,0.009],
                              [3069.155318,0.009],
                              [3091.395683,0.01],
                              [3113.79721,0.01],
                              [3136.361068,0.011],
                              [3159.088433,0.011],
                              [3181.980491,0.012],
                              [3205.038433,0.012],
                              [3228.263462,0.013],
                              [3251.65679,0.013],
                              [3275.219636,0.014],
                              [3298.953227,0.015],
                              [3322.858802,0.016],
                              [3346.937607,0.017],
                              [3371.190897,0.018],
                              [3395.619936,0.019],
                              [3420.225997,0.02],
                              [3445.010365,0.021],
                              [3469.97433,0.023],
                              [3495.119194,0.024],
                              [3520.446269,0.026],
                              [3545.956874,0.028],
                              [3571.652339,0.03],
                              [3597.534004,0.032],
                              [3623.603219,0.034],
                              [3649.861341,0.037],
                              [3676.309741,0.039],
                              [3702.949797,0.042],
                              [3729.782898,0.045],
                              [3756.810442,0.048],
                              [3784.033839,0.051],
                              [3811.454508,0.055],
                              [3839.073879,0.058],
                              [3866.893391,0.062],
                              [3894.914494,0.066],
                              [3923.13865,0.071],
                              [3951.56733,0.075],
                              [3980.202016,0.08],
                              [4009.0442,0.085],
                              [4038.095387,0.09],
                              [4067.357091,0.096],
                              [4096.830837,0.102],
                              [4126.518162,0.108],
                              [4156.420614,0.114],
                              [4186.539751,0.121],
                              [4216.877144,0.128],
                              [4247.434374,0.135],
                              [4278.213034,0.143],
                              [4309.21473,0.15],
                              [4340.441076,0.158],
                              [4371.893701,0.167],
                              [4403.574245,0.175],
                              [4435.484359,0.184],
                              [4467.625707,0.193],
                              [4499.999965,0.203],
                              [4532.60882,0.212],
                              [4565.453972,0.222],
                              [4598.537133,0.232],
                              [4631.860029,0.243],
                              [4665.424396,0.253],
                              [4699.231984,0.264],
                              [4733.284556,0.275],
                              [4767.583887,0.286],
                              [4802.131766,0.298],
                              [4836.929992,0.31],
                              [4871.980381,0.322],
                              [4907.284759,0.334],
                              [4942.844967,0.346],
                              [4978.662859,0.359],
                              [5014.740303,0.371],
                              [5051.079178,0.384],
                              [5087.68138,0.397],
                              [5124.548816,0.411],
                              [5161.68341,0.424],
                              [5199.087095,0.437],
                              [5236.761824,0.451],
                              [5274.709559,0.465],
                              [5312.932278,0.479],
                              [5351.431976,0.493],
                              [5390.210658,0.507],
                              [5429.270346,0.522],
                              [5468.613077,0.536],
                              [5508.240902,0.551],
                              [5548.155886,0.566],
                              [5588.360111,0.581],
                              [5628.855672,0.596],
                              [5669.64468,0.611],
                              [5710.729263,0.627],
                              [5752.111561,0.642],
                              [5793.793733,0.658],
                              [5835.77795,0.674],
                              [5878.066403,0.689],
                              [5920.661295,0.706],
                              [5963.564848,0.722],
                              [6006.779297,0.738],
                              [6050.306896,0.755],
                              [6094.149914,0.771],
                              [6138.310636,0.788],
                              [6182.791365,0.805],
                              [6227.59442,0.822],
                              [6272.722137,0.839],
                              [6318.176867,0.857],
                              [6363.960981,0.875],
                              [6410.076866,0.892],
                              [6456.526925,0.91],
                              [6503.313581,0.928],
                              [6550.439272,0.947],
                              [6597.906455,0.965],
                              [6645.717605,0.984],
                              [6693.875214,1.002],
                              [6742.381793,1.021],
                              [6791.239871,1.04],
                              [6840.451995,1.059],
                              [6890.02073,1.079],
                              [6939.94866,1.098],
                              [6990.238389,1.118],
                              [7040.892538,1.137],
                              [7091.913748,1.157],
                              [7143.304678,1.177],
                              [7195.068008,1.197],
                              [7247.206437,1.216],
                              [7299.722683,1.236],
                              [7352.619482,1.256],
                              [7405.899594,1.276],
                              [7459.565795,1.295],
                              [7513.620884,1.315],
                              [7568.067678,1.334],
                              [7622.909016,1.353],
                              [7678.147757,1.372],
                              [7733.786781,1.39],
                              [7789.828988,1.409],
                              [7846.2773,1.427],
                              [7903.13466,1.444],
                              [7960.404032,1.461],
                              [8018.088401,1.478],
                              [8076.190774,1.495],
                              [8134.714182,1.511],
                              [8193.661674,1.527],
                              [8253.036324,1.542],
                              [8312.841228,1.557],
                              [8373.079502,1.572],
                              [8433.754288,1.586],
                              [8494.868748,1.6],
                              [8556.426069,1.614],
                              [8618.429459,1.628],
                              [8680.882152,1.641],
                              [8743.787402,1.654],
                              [8807.14849,1.667],
                              [8870.968719,1.68],
                              [8935.251415,1.693],
                              [8999.99993,1.706],
                              [9065.217639,1.719],
                              [9130.907943,1.732],
                              [9197.074266,1.745],
                              [9263.720057,1.758],
                              [9330.848792,1.771],
                              [9398.463968,1.784],
                              [9466.569113,1.797],
                              [9535.167775,1.81],
                              [9604.263531,1.823],
                              [9673.859984,1.837],
                              [9743.960761,1.85],
                              [9814.569517,1.864],
                              [9885.689934,1.878],
                              [9957.325718,1.892],
                              [10029.480605,1.906],
                              [10102.158356,1.92],
                              [10175.36276,1.935],
                              [10249.097633,1.949],
                              [10323.366819,1.964],
                              [10398.174191,1.979],
                              [10473.523647,1.994],
                              [10549.419117,2.009],
                              [10625.864557,2.024],
                              [10702.863951,2.039],
                              [10780.421316,2.055],
                              [10858.540692,2.071],
                              [10937.226154,2.087],
                              [11016.481804,2.103],
                              [11096.311772,2.119],
                              [11176.720221,2.136],
                              [11257.711343,2.154],
                              [11339.289361,2.171],
                              [11421.458526,2.19],
                              [11504.223122,2.209],
                              [11587.587465,2.229],
                              [11671.555901,2.25],
                              [11756.132806,2.272],
                              [11841.322591,2.295],
                              [11927.129695,2.319],
                              [12013.558594,2.344],
                              [12100.613792,2.37],
                              [12188.299827,2.398],
                              [12276.621272,2.427],
                              [12365.582731,2.458],
                              [12455.18884,2.49],
                              [12545.444273,2.523],
                              [12636.353734,2.557],
                              [12727.921962,2.592],
                              [12820.153731,2.629],
                              [12913.05385,2.666],
                              [13006.627161,2.704],
                              [13100.878543,2.743],
                              [13195.81291,2.783],
                              [13291.43521,2.824],
                              [13387.750428,2.865],
                              [13484.763587,2.907],
                              [13582.479742,2.949],
                              [13680.90399,2.992],
                              [13780.041459,3.036],
                              [13879.89732,3.08],
                              [13980.476778,3.124],
                              [14081.785076,3.169],
                              [14183.827495,3.215],
                              [14286.609356,3.261],
                              [14390.136017,3.308],
                              [14494.412874,3.356],
                              [14599.445365,3.404],
                              [14705.238964,3.452],
                              [14811.799188,3.502],
                              [14919.13159,3.551],
                              [15027.241768,3.602],
                              [15136.135356,3.654],
                              [15245.818033,3.706],
                              [15356.295515,3.76],
                              [15467.573562,3.815],
                              [15579.657976,3.871],
                              [15692.5546,3.929],
                              [15806.26932,3.988],
                              [15920.808063,4.05],
                              [16036.176801,4.113],
                              [16152.381549,4.179],
                              [16269.428364,4.247],
                              [16387.323349,4.318],
                              [16506.072649,4.391],
                              [16625.682455,4.466],
                              [16746.159004,4.544],
                              [16867.508575,4.625],
                              [16989.737496,4.707],
                              [17112.852137,4.792],
                              [17236.858918,4.879],
                              [17361.764303,4.968],
                              [17487.574804,5.058],
                              [17614.29698,5.151],
                              [17741.937437,5.245],
                              [17870.502829,5.342],
                              [17999.999859,5.44],
                              [18130.435278,5.539],
                              [18261.815886,5.641],
                              [18394.148532,5.744],
                              [18527.440115,5.849],
                              [18661.697583,5.956],
                              [18796.927937,6.065],
                              [18933.138225,6.174],
                              [19070.33555,6.284],
                              [19208.527062,6.394],
                              [19347.719968,6.503],
                              [19487.921522,6.609],
                              [19629.139035,6.71],
                              [19771.379868,6.802],
                              [19914.651437,6.881]
                              ];
      const combinedData = [...decodedData.slice(0, filterTitle[i].startsWith('SW') ? 2703 : 3249), ...additionalRows.filter(row => !filterTitle[i].startsWith('SW'))];
      const customTargetCurvePoints = combinedData.map(point => `{${point[0]}, ${point[1]}}`);
      const thisChannel = jsonData.detectedChannels.find(channel => channel.commandId === filterTitle[i]);
      thisChannel.customTargetCurvePoints = customTargetCurvePoints;
      if (!filterTitle[i].startsWith("SW")) {
        let j = (i - dChannels) / 2;
        thisChannel.midrangeCompensation = false;
        thisChannel.frequencyRangeRolloff = 20000;
        thisChannel.customLevel = Number(parseFloat(customLevel[j]).toFixed(2));
        thisChannel.customDistance = Number(parseFloat(customDistance[j]).toFixed(2));
        thisChannel.customCrossover = customCrossover[j];
        thisChannel.customSpeakerType = "S";
        thisChannel.channelReport.customEnSpeakerConnect = 1;
      }
    }
    for (let channel of jsonData.detectedChannels) {
      if (channel.commandId.startsWith("SW")) {
        let customDistanceValue = parseFloat(customDistance[indexSW]) + parseFloat(channel.delayAdjustment);
        let customLevelValue = parseFloat(customLevel[indexSW]) + parseFloat(channel.trimAdjustment);
        channel.customDistance = parseFloat(customDistanceValue);
        let distanceValue = parseFloat(customDistance[indexSW]);
        channel.channelReport.distance = parseFloat(distanceValue);
        channel.customLevel = parseFloat(customLevelValue);
        channel.frequencyRangeRolloff = 250;
        channel.trimAdjustment = "0.0";
        channel.delayAdjustment = "0.0";
        if (invertSub === 2) {channel.channelReport.isReversePolarity = !channel.channelReport.isReversePolarity;}
      }
    }
    const adyOCA = JSON.stringify(jsonData);
    const blob = new Blob([adyOCA], {type: 'json'});
    const urlBlob = URL.createObjectURL(blob);
    var downloadLink = document.createElement("a");
    downloadLink.href = urlBlob;
    downloadLink.download = getadyName(fileName, "_OneOptimized.ady");
    downloadLink.style.display = "none";
    downloadLink.style.display = "none";
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
  }
  async function optimizerOCA() {
    try {
      const jsonData = JSON.parse(adyContents);
      const tName = checkModelSpeedOfSound(jsonData);
      console.info(`Based on your AVR model - ${tName}, speed of sound has been set to ${sOs.toFixed(1)} m/s for all distance calculations.`);
      console.warn(' - if you believe this setting is not correct for your receiver model, please notify OCA!');
      console.info(`************************************************************************************************************************`);
      await updateConstants(jsonData);
      var nSpeakers = await check_initialConditions();
      console.info(`************************************************************************************************************************`);
      const startTime = performance.now();
      if (nSpeakers === dChannels) {console.info('Optimization process started...');} else {throw Error('Number of channels mismatch!');}
      await getVectorAverages();
      const customLevel = await alignLevels();
      const customDistance = await alignDelays();
      await generateFilters();
      const customCrossover = await calculateCrossovers();
      await updateADY(customLevel, customDistance, customCrossover);
      console.info(`************************************************************************************************************************`);
      const endTime = performance.now();
      const totalTime = (endTime - startTime) / 1000;
      console.log(`'AUDYSSEY ONE' optimization has been completed with SUCCESS in ${totalTime.toFixed(3)} seconds!`);
      console.info(`************************************************************************************************************************`);
      console.info(`************************************************************************************************************************`);
      console.info("When prompted, save the .ady file to your PC and send it 'as is' to your MultEQ Editor app.");
      console.info("You will then be prompted to save a copy of this log for your records as a text file.");
      console.info("Next, transfer the ady file 'as is' from MultEQ Editor app to your AV receiver as you normally would.");
      console.info("Some Android app versions may prompt 'corrupt file' unless the ady file is transferred by using certain cloud drives.");
      console.info("The Editor app graphs will no longer represent final speaker responses due to the special filtering technique implemented.");
      console.info("Speaker responses with 'final' indices under REW / All SPL tab are your expected post-calibration responses.");
      console.info("You can find detailed information about most issues and solutions in the YT video comments.");
      console.info(`************************************************************************************************************************`);
      console.info('YouTube video (https://youtu.be/iU1ZBsru76M) contains a download link for several Dolby Atmos & DTS-X test clips');
      console.info("compatible for playback via a USB key on your Blu-ray player for testing.");
      console.info(`************************************************************************************************************************`);
      console.info('Enjoy your new sound!');
      saveLogToFile();
    }
    catch (error) {
      console.error(error, "- program execution has stopped!");
    }
  }
  function saveLogToFile() {
    const logContent = document.getElementById('logContainer').textContent;
    const blob = new Blob([logContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'A1_optimization_log.txt';
    link.click();
    URL.revokeObjectURL(url);
  }
  (function () {
    const logContainer = document.getElementById('logContainer');
    function scrollToBottom() {
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    const originalWarn = console.warn;
    console.warn = function (...args) {
      const warningMessage = args.join(' ');
      const warningEntry = `${new Date().toLocaleTimeString()} [WARNING] ${warningMessage}\n`;
      logContainer.textContent += warningEntry;
      scrollToBottom();
      originalWarn.apply(console, args);
    };
    const originalInfo = console.info;
        console.info = function (...args) {
          const warningMessage = args.join(' ');
          const warningEntry = `${new Date().toLocaleTimeString()} [INFO] ${warningMessage}\n`;
          logContainer.textContent += warningEntry;
          scrollToBottom();
          originalWarn.apply(console, args);
        };
    const originalLog = console.log;
    console.log = function (...args) {
      const logMessage = args.join(' ');
      const logEntry = `${new Date().toLocaleTimeString()} [LOG] ${logMessage}\n`;
      logContainer.textContent += logEntry;
      scrollToBottom();
      originalLog.apply(console, args);
    };
    const originalError = console.error;
    console.error = function (...args) {
      const errorMessage = args.join(' ');
      const errorEntry = `${new Date().toLocaleTimeString()} [ERROR] ${errorMessage}\n`;
      logContainer.textContent += errorEntry;
      scrollToBottom();
      originalError.apply(console, args);
    };
  })();

</script>
</body></html>