<!-- 
  Copyright (c) [2024] [OCA - https://www.youtube.com/@OCAudiophile]

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, and to permit persons to
  whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  Redistribution and use in source and binary forms, with or without
  modification, are not permitted for commercial purposes without the explicit
  permission of the author.
-->
<!DOCTYPE html><html>
<head>
  <title>Audyssey One - OCA 2024</title>
  <style>
    body {font-family: Arial, sans-serif;background-color: #f2f2f2;}
    .container {max-width: 1080px;margin: 0 auto;padding: 20px;}
    h2 {
      text-align: center;
      font-size: 24px;
      margin-bottom: 20px;
      color: #fff;
      background-color: #6fa3e7;
      padding: 10px 20px;
      border-radius: 10px;
    }
    strong {font-style: italic;}
    ol {padding-left: 20px;}
    .button-container {display: flex;justify-content: flex-start;margin-bottom: 20px;}
    button {
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 30px;
      border: none;
      color: #fff;
      background-color: #6fa3e7;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      cursor: pointer;
      width: 200px;
    }
      button:hover {background-color: #4c6cb3;}
      button:disabled {opacity: 0.5;cursor: not-allowed;}
    #fileInput {display: none;}
    #logContainer {
      background-color: #333;
      color: #fff;
      padding: 10px;
      border-radius: 5px;
      max-height: 400px; /* Adjust the height as needed */
      overflow-y: auto; /* Add scrollbar if log exceeds max-height */
    }
    h2.log-heading {
      font-family: Arial, sans-serif;
      font-size: 16px; /* Adjust the font size as needed */
      text-indent: 5px; /* Adjust the left indent value as needed */
      margin-bottom: 5px; /* Adjust the bottom margin as needed */
      width: 120px;
      background-color: #808080;
      color: #fff;
    }
  </style>
</head>
<body>
<div class="container">
    <h2><strong>1-click</strong> Audyssey Optimization</h2>
    <ol>
      <li>Download the latest REW beta version (v5.40 Beta 18 or above) from <a href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>.</li>
      <li>Remove any existing microphone calibration file from REW (Navigate to Preferences, then go to the "Cal files" tab).</li>
      <li>Under Preferences, set REW's "Maximum measurements" to 300 (This requires restarting REW).</li>
      <li>Click the "Upload" button below to select and save the Audyssey calibration file (extension: '.ady') transferred from your MultEQ Editor app.</li>
    </ol>
    <input type="file" id="fileInput" accept=".ady" onchange="handle_adyUpload(event)">
    <div class="button-container">
      <button id="button1" onclick="document.getElementById('fileInput').click()">Upload</button>
    </div>
    <ol start="5">
      <li>When prompted, save the target curve file "DrTooleTargetCurve.txt" and the zipped measurements file in a folder on your computer.</li>
      <li>In REW, navigate to the "EQ" tab, then House Curve, and select "DrTooleTargetCurve.txt" you saved earlier.</li>
      <li>Open the zip file (no need to extract it), select all files (CTRL+A for Windows, command+C for Mac), and drag and drop them onto REW.</li>
      <li>All Audyssey measurements will be automatically imported in the correct order; do not change their orders or names.</li>
      <li>Start the REW API server (Under Preferences, navigate to API).</li>
      <li>For better performance, keep REW on "SPL & Phase" tab, untick "Animate measurement list" in Preferences/View and close all REW child windows.</li>
    </ol>
    <div class="button-container">
      <button id="button2" onclick="startButton_clicked()" disabled>Start Optimization</button>
    </div>
    <br>
    <h2 class="log-heading">System Log:</h2>
        <pre id="logContainer"></pre>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>
<script>

  let adyContents; let fileName;
  let dChannels; let subtrueMax;
  let indexSW; let cDist;
  let sOs;
  let delay = 250; //increase this value if your machine is slow and needs more time to process operations
  const baseUrl = 'http://localhost:4735/measurements';
  const pollUrl = 'http://localhost:4735/measurements/process-result';
  let averageLvl;

  function checkModelSpeedOfSound(jsonData) {
    const targetModelName = jsonData.targetModelName;
    const lastSixDigits = targetModelName.slice(-6);
    const specialModels = ["X6300H", "X4300H", "X3300W", "X2300W", "X1300W", "X1400H", "X2400H", "X3400H", "X4400H", "X6400H", "AV7703", "SR7011", "SR6011", "SR5011", "NR1607", "NR1608", "SR5012", "SR6012", "SR7012", "SR8012", "AV7704"]; //Add your model name here if your speed of sound setting is 300 m/s.
    const isSpecialModel = specialModels.includes(lastSixDigits);
    (isSpecialModel ? sOs = 300.0 : sOs = 343.0);
    return targetModelName;
  }
  function updateConstants(jsonData) {
    let nSubs = 0;
    const channelKeys = Object.keys(jsonData.detectedChannels);
    dChannels = channelKeys.length;
    for (let i = dChannels; i >= 1; i--) {
      const key = channelKeys[i - 1];
      const commandId = jsonData.detectedChannels[key].commandId;
      if (commandId.startsWith("SW")) {
        nSubs++;
      } else {
        dChannels -= nSubs; dChannels++; break;
      }
    }
    if (!nSubs) {throw new Error('Optimization will not work with systems with NO subwoofer!')}
    subtrueMax = 0.0;
    if (nSubs > 1) {
        for (let i = dChannels - 1; i < Object.keys(jsonData.detectedChannels).length; i++) {
                const delayAdjustment = parseFloat(jsonData.detectedChannels[i].delayAdjustment);
                if (delayAdjustment > subtrueMax) {subtrueMax = delayAdjustment;}
              }
    }
    subtrueMax = 6.0 - subtrueMax;
    cDist = parseFloat(jsonData.detectedChannels[1].customDistance);
    if (!cDist > 0.0) {cDist = parseFloat(jsonData.detectedChannels[1].channelReport.distance);}
  }
  function handle_adyUpload(event) {
    document.getElementById("button2").disabled = false;
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
      adyContents = e.target.result;
      const jsonData = JSON.parse(adyContents);
      const zip = new JSZip();
      for (const key in jsonData.detectedChannels) {
        if (jsonData.detectedChannels.hasOwnProperty(key)) {
          const responseData = jsonData.detectedChannels[key].responseData;
          for (const arrayKey in responseData) {
            if (responseData.hasOwnProperty(arrayKey)) {
             const arrayData = responseData[arrayKey].join('\n');
              const rewHeader = "* Impulse Response data saved by REW\n0 // Peak value before normalisation\n0 // Peak index\n16384 // Response length\n2.0833333333333333E-5 // Sample interval (seconds)\n0.0 // Start time (seconds)\n* Data start\n" + arrayData;
              var measurementName = jsonData.detectedChannels[key].commandId + arrayKey + '.txt';
              zip.file(measurementName, rewHeader);
            }
          }
        }
      }
      zip.generateAsync({type: "blob"}).then(function (content) {
        const urlZip = URL.createObjectURL(content);
        var downloadLink = document.createElement("a");
        downloadLink.href = urlZip;
        fileName = file.name;
        downloadLink.download = getadyName(file.name, "_extractedMeasurements.zip");
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      });
      const targetCurve = `
      6.3 2.357,
      6.7 2.357,
      7.1 2.357,
      7.5 2.357,
      8 2.357,
      8.5 2.357,
      9 2.357,
      9.5 2.357,
      10 2.357,
      10.6 2.357,
      11.2 2.357,
      11.8 2.357,
      12.5 2.357,
      13.2 2.357,
      14 2.357,
      15 2.357,
      16 2.357,
      17 2.357,
      18 2.357,
      19 2.356,
      20 2.354,
      21.2 2.35,
      22.4 2.343,
      23.6 2.336,
      25 2.328,
      26.5 2.32,
      28 2.311,
      30 2.3,
      31.5 2.292,
      33.5 2.282,
      35.5 2.273,
      37.5 2.263,
      40 2.253,
      42.5 2.242,
      45 2.231,
      47.5 2.221,
      50 2.21,
      53 2.197,
      56 2.183,
      60 2.162,
      63 2.144,
      67 2.119,
      71 2.092,
      75 2.065,
      80 2.028,
      85 1.99,
      90 1.952,
      95 1.912,
      100 1.87,
      106 1.815,
      112 1.76,
      118 1.706,
      125 1.648,
      132 1.592,
      140 1.531,
      150 1.461,
      160 1.395,
      170 1.333,
      180 1.274,
      190 1.219,
      200 1.167,
      212 1.107,
      224 1.051,
      236 0.998,
      250 0.939,
      265 0.88,
      280 0.824,
      300 0.754,
      315 0.704,
      335 0.641,
      355 0.582,
      375 0.526,
      400 0.461,
      425 0.399,
      450 0.341,
      475 0.287,
      500 0.235,
      530 0.176,
      560 0.12,
      600 0.05,
      630 0.001,
      670 -0.062,
      710 -0.12,
      750 -0.175,
      800 -0.24,
      850 -0.3,
      900 -0.358,
      950 -0.412,
      1000 -0.464,
      1060 -0.521,
      1120 -0.575,
      1180 -0.627,
      1250 -0.683,
      1320 -0.737,
      1400 -0.794,
      1500 -0.86,
      1600 -0.92,
      1700 -0.972,
      1800 -1.014,
      1900 -1.042,
      2000 -1.057,
      2120 -1.066,
      2240 -1.069,
      2360 -1.072,
      2500 -1.075,
      2650 -1.079,
      2800 -1.082,
      3000 -1.083,
      3150 -1.084,
      3350 -1.084,
      3550 -1.085,
      3750 -1.086,
      4000 -1.091,
      4250 -1.099,
      4500 -1.111,
      4750 -1.132,
      5000 -1.159,
      5300 -1.198,
      5600 -1.239,
      6000 -1.291,
      6300 -1.329,
      6700 -1.377,
      7100 -1.422,
      7500 -1.464,
      8000 -1.511,
      8500 -1.55,
      9000 -1.577,
      9500 -1.594,
      10000 -1.606,
      10600 -1.616,
      11200 -1.62,
      11800 -1.622,
      12500 -1.622,
      13200 -1.623,
      14000 -1.623,
      15000 -1.622,
      16000 -1.621,
      17000 -1.619,
      18000 -1.615,
      19000 -1.612,
      20000 -1.61,
      21200 -1.609,
      22400 -1.609,
      23600 -1.609`;
      const blob = new Blob([targetCurve], {type: 'text/plain'});
      const urlBlob = URL.createObjectURL(blob);
      var downloadLink = document.createElement("a");
      downloadLink.href = urlBlob;
      downloadLink.download = "DrTooleTargetCurve.txt"; 
      downloadLink.style.display = "none";
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    };
    reader.readAsText(file);
  }
  function getadyName(fileName, suffix) {
    var dotIndex = fileName.lastIndexOf(".");
    var modifiedName = fileName.substring(0, dotIndex) + suffix;
  return modifiedName;
  }
  function startButton_clicked() {
    document.getElementById('button1').disabled = true;
    optimizerOCA();
  }
  async function fetch_mREW(indice = null, method = 'GET', _body = null){
      let body;
      let requestUrl;
      if (indice === null) {requestUrl = baseUrl;} else {requestUrl = baseUrl + `/${indice}`};
      if (method === 'PUT') {body = _body}
      while(true) {
          try {
              const response = await fetch(requestUrl,{
                method: method,
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body)
                });
              if (!response.ok) {
                  await new Promise(resolve => setTimeout(resolve, delay)); 
                  } else {const data = await response.json();
                          return data;}
                   
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postNext(processName, indices, parameters = null) {
      let requestUrl; let body;
      if (Array.isArray(indices)) {requestUrl = `${baseUrl}/process-measurements`}
          else {(parameters === null ? requestUrl = `${baseUrl}/${indices}/eq/command` : requestUrl = `${baseUrl}/${indices}/command`)};
      if (requestUrl.endsWith('/command')) {body = {command: processName}}
          else body = {processName: processName};
      if (parameters != null) {body = { ...body, parameters: parameters}};
      if (Array.isArray(indices)) {body = { ...body, measurementIndices: indices}};
          await fetch(requestUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
          });
      const object = await pollComplete(processName);
      return object;
  }
  async function pollComplete(processName) {
      while(true) {
          try {
              const response = await fetch(pollUrl);
              if (!response.ok) {
                  throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === "Completed" && data.processName === processName) {
                  return data;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postSafe(requestUrl, parameters) {
      while(true) {
          try {
              const response = await fetch(requestUrl,{
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(parameters)
              });
              if (!response.ok) {
                  throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === "Update processed") {
                  return data;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postDelete(indice) {
      const mDeleted = `Measurement ${indice} deleted`
      while(true) {
          try {
              const response = await fetch(`${baseUrl}/${indice}`,{
                method: 'DELETE',
                headers: {'Content-Type': 'application/json'},
                });
              if (!response.ok) {
                   throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === mDeleted) {
                  return indice;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      //delay--;
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              //delay++;
              await new Promise(resolve => setTimeout(resolve, delay)); 
              }
      }
  }
  async function fetchSafe(extUrl, indice, parameters = null) {
    const requestUrl = `${baseUrl}/${indice}/${extUrl}`;
    let options;
    if (parameters === null) {
      options = {
        method: 'GET'
      };
    } else {
      options = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(parameters)
      };
    }
    while (true) {
      try {
        const response = await fetch(requestUrl, options);
        if (!response.ok) {
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          const data = await response.json();
          return data;
        }
      } catch (error) {
        console.error('Error fetching result:', error);
      }
    }
  }
  async function check_initialConditions() {
    
    const measurements = await fetch_mREW();
    const titles = {};
    let titleIndices = {};
    const mCount = Object.keys(measurements).length
    for (let i = 1; i <= mCount; i++) {
      const title = measurements[i].title;
      const titleKey = title.replace(/\d+/g, '');
      if (!/^\D+(\d+)?$/.test(titleKey)) {
        throw new Error(`Title ${titleKey} does not end with an indice.`);
      }
      if (!titles[titleKey]) {
        titles[titleKey] = true;
        titleIndices[titleKey] = [];
      }
      const matchResult = title.match(/\d+/);
      if (matchResult && matchResult.length > 0) {
        titleIndices[titleKey].push(parseInt(matchResult[0]));
      } else {
        throw new Error(`No indices found in speaker title: ${title}`);
      }
    }
    nSpeakers = Object.keys(titles).length;
    const indicesCounts = Object.values(titleIndices).map(indices => indices.length);
    const isIndicesEqual = indicesCounts.every(count => count === indicesCounts[0]);
    if (!isIndicesEqual) {
      throw new Error('Titles have different numbers of indices.');
    }
    for (const titleKey in titleIndices) {
      const indices = titleIndices[titleKey];
      const sortedIndices = [...indices].sort((a, b) => a - b);
      if (JSON.stringify(indices) !== JSON.stringify(sortedIndices)) {
        throw new Error(`Indices of ${titleKey} are not in order.`);
      }
    }
    const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
    if (tcResponse.ok) {
      const tcPath = await tcResponse.json();
      if (tcPath && tcPath.message) {
        console.log(`Applying Target Curve located @ ${tcPath.message}`);
      } else {
        throw new Error('Failed to locate target curve! Browse to and select "DrTooleTargetCurve.txt" in "REW / EQ window / House curve.');
      }
    } else {
      throw new Error(`Failed to fetch target curve, please start the API server! HTTP status code: ${tcResponse.status}.`);
    }
    return (nSpeakers);
  }
  async function getVectorAverages() {
    const measurements = await fetch_mREW();
    const mCount = Object.keys(measurements).length
    const micPositions = mCount / dChannels;
    console.log(`Transposing measurements from ${micPositions} different microphone positions to the primary listening position...`);
    for (let i = 1; i <= mCount; i+= micPositions) {
      const indices = Array.from({length: micPositions}, (_, j) => i + j);
      await postNext('Cross corr align', indices);
      await postNext('Vector average', indices);
      const tIndex = mCount + 1 + (i - 1) / micPositions;
      const newTitle = measurements[i].title.slice(0,-1) + "o";
      await fetch_mREW(tIndex, 'PUT', {title: newTitle});
    };
    console.info(`Done!`);
    console.info(`Cleaning up processed measurements...`);
    for (let i = mCount; i > 0; i--) {
      await postDelete(i);
      await new Promise(resolve => setTimeout(resolve, delay * 1.15)); }
      console.log(`Done!`);
  }
  async function alignLevels() {
    let customLevel = new Array(dChannels + 1).fill(0);
    let targetSum = 0;
    let target = {};
    let title = {};
    indexSW = 1;
    console.log('Calculating precise speaker volume levels...');
    for (let i = 1; i <= dChannels; i++) {
      await postNext('Add SPL offset', i, {offset: -42});
      const mData = await fetch_mREW(i);
      title[i] = mData.title;
      await postSafe(`${baseUrl}/${i}/target-settings`, { shape: "None" });
      await postSafe(`${baseUrl}/${i}/room-curve-settings`, { addRoomCurve: false });
      if (title[i].startsWith("SW")) {indexSW = i; continue;}
      await postNext('Smooth', i, {smoothing: "1/1"});
      await postNext('Calculate target level', i);
      await postNext('Smooth', i, {smoothing: "None"});
      const targetResponse = await fetchSafe('target-level',i);
      target[i]= parseFloat(targetResponse);
      console.log(`${title[i]}: ${target[i]} dB`);
      targetSum += target[i];
    }
    averageLvl = parseFloat(targetSum / (dChannels - 1.0));
    console.info(`Optimized target volume level: ${averageLvl} dB`);
    console.info(`Total number of speakers averaged (excludes subwoofer): ${dChannels - 1}`);
    console.log('Finalized speaker volume settings:');
    for (let i = 1; i <= dChannels; i++) {
      if (i === indexSW) {
        console.info(`Optimizing subwoofer volume adjustment...`);
        await fetchSafe('target-level',i, averageLvl);
        await postNext('Generate target measurement', indexSW);
        const indexTC = dChannels + 1;
        const volShift = await postNext('Align SPL', [indexSW, indexTC], {"frequencyHz": "63","spanOctaves": "3","targetdB": "average"});
        const volDelta = parseFloat(volShift.results[indexSW].alignSPLOffsetdB);
        customLevel[i] = (Math.round(volDelta * 4) / 2).toFixed(1);
        console.log(`${title[indexSW].slice(0,-1)}: ${customLevel[i]} dB ; with ${volDelta * 2 - customLevel[i]} dB filter compensation`);
        await postNext('Add SPL offset', indexSW, {offset: volDelta});
        await postNext('Add SPL offset', indexTC, {offset: volDelta});
        continue;
      }
    const volDif = parseFloat(averageLvl - target[i]);
    customLevel[i] = (Math.round(volDif * 2) / 2).toFixed(1);
    console.log(`${title[i].slice(0,-1)}: ${customLevel[i]} ; with ${volDif - customLevel[i]} dB filter compensation`)
    await postNext('Add SPL offset', i, {offset: customLevel[i]});
    }
    return customLevel;
  }
  async function alignDelays() {
  console.info('Deriving optimal speaker distances through cross-correlation analysis...');
  let customDistance = new Array(dChannels + 1).fill(0);
  const minDelay = parseFloat(6.0 / sOs);
  let mDist = {};
  let mSec = {};
  var minSec = cDist / sOs;
  const indices = Array.from({ length: dChannels }, (_, index) => index + 1);
  const mDelay = await postNext('Cross corr align', indices);
  const measurements = await fetch_mREW();
  for (let i = 1; i <= dChannels; i++) {
    mSec[i] = parseFloat(mDelay.results[i][`Adjustment (seconds)`]);
    customDistance[i] = Number((cDist + (mSec[i] * sOs)).toFixed(2));
    if (mSec[i] < minSec) {
      minSec = mSec[i];
    }
    console.log(`${measurements[i].title.slice(0, -1)}: ${customDistance[i]}m`);
  }
  let minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
  let minChk = Number(minChk_val.toFixed(2));
  let finDist_val = cDist + minSec * sOs + minChk;
  customDistance[indexSW] = Number(finDist_val.toFixed(2));
  if (minChk <= subtrueMax) {
    console.info(`Subwoofer distance is 'optimally' set @ ${customDistance[indexSW]}m and is within the AV Receiver's speaker spacing limits.`);
  } else {
    console.warn(`Calculated optimal subwoofer distance of ${customDistance[indexSW]}m exceeds the receiver's max. speaker spacing limit! [${minChk}m vs ${subtrueMax.toFixed(2)}m]`);
    console.info('Attempting to re-align the sub...');
    await postNext('Remove IR delays', [1, indexSW]);
    await postNext('Remove IR delays', [1, indexSW]);
    await postNext('Remove IR delays', [1, indexSW]);
    const resultC = await fetch_mREW(1);
    const resultSW = await fetch_mREW(indexSW);
    mSec[1] = parseFloat(resultC.cumulativeIRShiftSeconds);
    mSec[indexSW] = parseFloat(resultSW.cumulativeIRShiftSeconds);
    minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
    minChk = Number(minChk_val.toFixed(2));
    finDist_val = cDist + minSec * sOs + minChk;
    customDistance[indexSW] = Number(finDist_val.toFixed(2));
    if (minChk <= subtrueMax) {
      console.info(`Subwoofer distance is re-set to ${customDistance[indexSW]}m and is now within receiver speaker spacing limits. [${minChk}m vs ${subtrueMax.toFixed(2)}m]`);
    } else {
      console.warn(`Recalculated subwoofer distance of ${customDistance[indexSW]}m still exceeds the receiver's max. speaker spacing limit! [${minChk}m vs ${subtrueMax.toFixed(2)}m]`);
      console.info('Attempting to re-align the sub...');
      await postNext('Align IR start', [1, indexSW]);
      await postNext('Align IR start', [1, indexSW]);
      const resultC = await fetch_mREW(1);
      const resultSW = await fetch_mREW(indexSW);
      mSec[1] = parseFloat(resultC.cumulativeIRShiftSeconds);
      mSec[indexSW] = parseFloat(resultSW.cumulativeIRShiftSeconds);
      minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
      minChk = Number(minChk_val.toFixed(2));
      finDist_val = cDist + minSec * sOs + minChk;
      customDistance[indexSW] = Number(finDist_val.toFixed(2));
      if (minChk <= subtrueMax) {
        console.info(`Subwoofer distance is again re-set to ${customDistance[indexSW]}m and is finally within the receiver speaker spacing limits. [${minChk}m vs ${subtrueMax.toFixed(2)}m]`);
      } else {
        console.warn(`Recalculated subwoofer distance of ${customDistance[indexSW]}m still exceeds the receiver's max. speaker spacing limit! [${minChk}m vs ${subtrueMax.toFixed(2)}m]`);
        customDistance[indexSW] = Number((subtrueMax + cDist + minSec * sOs).toFixed(2));
        console.info(`Setting subwoofer distance 'suboptimally' to ${customDistance[indexSW]}m (max. allowed)`);
        console.warn("Please ensure to inspect your setup thoroughly to identify the root cause of the significant delay!")
      }
    }
  }
  return customDistance;
  }
  async function generateFilters() {
    console.info(`Crafting custom room correction filters...`);
    delay *= 1.5;
    const measurements = await fetch_mREW();
    let indexTC = dChannels + 1;
    await postNext('Minimum phase version', indexTC, {
      "include cal": false,
      "append lf tail": false, 
      "append hf tail": false,
      "frequency warping": false,
      "replicate data": false
    });
    await postDelete(indexTC);
    await fetch_mREW(indexTC,'PUT', {title: "Dr Toole target curve"});
    await new Promise(resolve => setTimeout(resolve, delay * 1.15));
    for (let i = 1; i <= dChannels; i++) {
      await postNext('Minimum phase version', i, {
        "include cal": false,
        "append lf tail": false, 
        "append hf tail": false,
        "frequency warping": false,
        "replicate data": false
      });
      ii = dChannels + i * 5 - 3;
      
      await postNext('Arithmetic', [ii, indexTC], {
        function: "A / B",
        regularisation: "0",
        lowerLimit: "0",
        upperLimit: "0"});
      await postNext('Arithmetic', [ii + 1, ii + 1], {
        function: "1 / A",
        maxGain: "0",
        lowerLimit: "0",
        upperLimit: "200",
        autoTarget: "0",
        excludeNotches: false});
      await postNext('Minimum phase version', ii + 2, {
        "include cal": false,
        "append lf tail": false, 
        "append hf tail": false,
        "frequency warping": false,
        "replicate data": false
      });
      await postNext('Arithmetic', [i, ii + 3], {function: "A * B"});
      const finTitle = measurements[i].title.replace("o","final");
      await fetch_mREW(ii + 4, 'PUT', {title: finTitle});
      const filtTitle = measurements[i].title.replace("o","");
      await fetch_mREW(ii + 3, 'PUT', {title: filtTitle});
    }
    console.log(`Done!`);
  }
  async function calculateCrossovers() {
    console.info(`Pinpointing optimal crossover frequencies...`);
    let customCrossover = new Array(dChannels + 1).fill(0);
    delay *= 2.0;
    const level = averageLvl;
    const measurements = await fetch_mREW();
    const indexTC = dChannels + 1;
    const indexSWf = dChannels + indexSW * 5 + 1;
    const start = dChannels + 1;
    const end = dChannels * 6 + 1;
    for (let i = start; i <= end; i += 5) {
      if (i === indexSWf) {continue;}
      await postNext('Smooth', i, {smoothing: "1/1"});
      if (i === indexTC) {continue;}
      const magBase64 = await fetchSafe('frequency-response',i);
      const bytes = Uint8Array.from(atob(magBase64.magnitude), c => c.charCodeAt(0));
      const buffer = bytes.buffer;
      const floatArray = new Float32Array(buffer);
      const dataView = new DataView(buffer);  
      const arr = []; 
      for (let j = 0; j < floatArray.length; j++) { 
        const splValue = dataView.getFloat32(j * 4);
        arr.push(splValue);
      }
      const sigmaTable = [
      { name: "F", matchingRow: 285, levelDelta: 3.41 },
      { name: "40", matchingRow: 381, levelDelta: 3.519 },
      { name: "60", matchingRow: 437, levelDelta: 3.659 },
      { name: "80", matchingRow: 477, levelDelta: 3.818 },
      { name: "90", matchingRow: 493, levelDelta: 3.924 },
      { name: "10", matchingRow: 507, levelDelta: 4.044 },
      { name: "11", matchingRow: 521, levelDelta: 4.092 },
      { name: "12", matchingRow: 533, levelDelta: 4.179 },
      { name: "15", matchingRow: 564, levelDelta: 4.398 },
      { name: "18", matchingRow: 589, levelDelta: 4.596 },
      { name: "20", matchingRow: 603, levelDelta: 4.733 },
      { name: "25", matchingRow: 634, levelDelta: 4.956 }];
      const differences = [];
      for (const { name, matchingRow, levelDelta } of sigmaTable) {
        const decodedValue = arr[matchingRow];
        //console.log(decodedValue)
        const targetValue = level - levelDelta;
        //console.log(targetValue)
        const sigmaOCA = level - levelDelta - decodedValue;
        differences.push({ frequency: name, sigmaOCA });
      }
      let minAbsDifference = Infinity;
      let minFrequency = null;
      const k = (i - dChannels - 1) / 5;
      for (const { frequency, sigmaOCA } of differences) {
        const absDifference = Math.abs(sigmaOCA);
        if (absDifference < minAbsDifference) {
            minAbsDifference = absDifference;
            customCrossover[k] = frequency;
        }
      }
      let displayFrequency;
      if (customCrossover[k] === 'F') {
          displayFrequency = 'FULL RANGE <= 20';
      } else if (['40', '60', '80', '90'].includes(customCrossover[k])) {
          displayFrequency = customCrossover[k];
      } else {
          displayFrequency = parseInt(customCrossover[k]) * 10;
      }
      console.info(`Crossover frequency for ${measurements[i].title.slice(0,-5)} is set @ ${displayFrequency}Hz`);
    }
    return customCrossover;  
  }
  async function updateADY(customLevel, customDistance, customCrossover){
    console.info(`Consolidating all optimal adjustments into the final calibration file...`);
    let filterTitle = {};
    const jsonData = JSON.parse(adyContents);
    jsonData.dynamicVolume=false;
    jsonData.lfc=false;
    jsonData.dynamicEq=false;
    jsonData.enTargetCurveType = 1;

    for (const key in jsonData.detectedChannels) {
      if (jsonData.detectedChannels.hasOwnProperty(key)) {
        const responseData = jsonData.detectedChannels[key].responseData;
        for (const arrayKey in responseData) {
          if (responseData.hasOwnProperty(arrayKey)) {
            const zerosArray = Array(16383).fill("0");
            zerosArray.unshift("1");
            responseData[arrayKey] = zerosArray;
          }
        }
      }
    }
    const start = dChannels + 5;
    const end = dChannels * 6;
    for (let i = start; i <= end; i += 5) {
      const mData = await fetch_mREW(i);
      filterTitle[i] = mData.title;
      const fetchedData = await fetchSafe('frequency-response',i);
      const magBase64 = fetchedData.magnitude;
      const startFreq = fetchedData.startFreq;
      const freqStep = fetchedData.freqStep;
      const bytes = Uint8Array.from(atob(magBase64), c => c.charCodeAt(0));
      const buffer = bytes.buffer;
      const floatArray = new Float32Array(buffer);
      const dataView = new DataView(buffer);
      for (let i = 0; i < floatArray.length; i++) {floatArray[i] = dataView.getFloat32(i * 4);}
      const firstColumn = new Float32Array(floatArray.length);
      for (let i = 0; i < firstColumn.length; i++) {firstColumn[i] = startFreq + i * freqStep;}
      const decodedData = new Array(floatArray.length);
      for (let i = 0; i < decodedData.length; i++) {decodedData[i] = [firstColumn[i], floatArray[i]];}
      const additionalRows = [ //anti HFR1
      [3000, 0.011],[3150, 0.016],[3350, 0.038],[3550, 0.057],[3750, 0.086],[4000, 0.139],[4250, 0.208],
      [4500, 0.288],[4750, 0.377],[5000, 0.473],[5300, 0.591],[5600, 0.710],[6000, 0.872],[6300, 0.993],
      [6700, 1.151],[7100, 1.307],[7500, 1.449],[8000, 1.587],[8500, 1.701],[9000, 1.802],[9500, 1.902],
      [10000, 2.005],[10600, 2.137],[11200, 2.303],[11800, 2.515],[12500, 2.810],[13200, 3.128],[14000, 3.518],
      [15000, 4.063],[16000, 4.735],[17000, 5.522],[18000, 6.281],[19000, 6.876],[20000, 7.225]];
      const combinedData = [...decodedData.slice(0, filterTitle[i].startsWith('SW') ? 2703 : 3249), ...additionalRows.filter(row => !filterTitle[i].startsWith('SW'))];
      const customTargetCurvePoints = combinedData.map(point => `{${point[0]}, ${point[1]}}`);
      const thisChannel = jsonData.detectedChannels.find(channel => channel.commandId === filterTitle[i]);
      thisChannel.customTargetCurvePoints = customTargetCurvePoints;
      if (!filterTitle[i].startsWith("SW")) {
        let j = (i - dChannels) / 5;
        thisChannel.midrangeCompensation = false;
        thisChannel.frequencyRangeRolloff = 20000;
        thisChannel.customLevel = Number(parseFloat(customLevel[j]).toFixed(2));
        thisChannel.customDistance = Number(parseFloat(customDistance[j]).toFixed(2));
        thisChannel.customCrossover = customCrossover[j];
        thisChannel.customSpeakerType = customCrossover[j] === "F" ? "L" : "S";
        thisChannel.channelReport.customEnSpeakerConnect = customCrossover[j] === "F" ? 2 : 1;
      }
    }
    for (let channel of jsonData.detectedChannels) {
        if (channel.commandId.startsWith("SW")) {
            let customDistanceValue = parseFloat(customDistance[indexSW]) + parseFloat(channel.delayAdjustment);
            let customLevelValue = parseFloat(customLevel[indexSW]) + parseFloat(channel.trimAdjustment);
            channel.customDistance = parseFloat(customDistanceValue);
            channel.customLevel = parseFloat(customLevelValue);
            channel.frequencyRangeRolloff = 250;
        }
    }
      const adyOCA = JSON.stringify(jsonData);
      const blob = new Blob([adyOCA], {type: 'json'});
      const urlBlob = URL.createObjectURL(blob);
      var downloadLink = document.createElement("a");
      downloadLink.href = urlBlob;
      downloadLink.download = getadyName(fileName, "_OneOptimized.ady");
      downloadLink.style.display = "none";
      downloadLink.style.display = "none";
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
  }
  async function optimizerOCA() {
    try {
      const jsonData = JSON.parse(adyContents);
      const tName = checkModelSpeedOfSound(jsonData);
      console.info(`Speed of sound has been automatically set to ${sOs.toFixed(1)} m/s for your AV Receiver model: ${tName}`);
      console.warn('(If you think this setting is incorrect, please notify OCA!)');
      updateConstants(jsonData);
      var nSpeakers = await check_initialConditions();
      if (nSpeakers === dChannels) {console.info('Optimization process started...');} else {throw Error('Number of channels mismatch!');}
      await getVectorAverages();
      const customLevel = await alignLevels();
      const customDistance = await alignDelays();
      await generateFilters();
      const customCrossover = await calculateCrossovers();
      await updateADY(customLevel, customDistance, customCrossover);
      console.log("'Audyssey One' optimization is completed with SUCCESS!");
      console.info("When prompted, save the .ady file to your PC and send it to your MultEQ Editor app.");
      console.info("Then transfer it 'as is' from the app to your AV receiver.");
      console.info('The video description contains a download link for several Dolby Atmos & DTS-X test clips');
      console.info("compatible for playback via a USB key on your Blu-ray player.");
      console.info('ENJOY!');
    }
    catch (error) {
      console.error(error, "- program execution has stopped!");
    }
  }
  (function () {
    const logContainer = document.getElementById('logContainer');
    function scrollToBottom() {
      logContainer.scrollTop = logContainer.scrollHeight;
    }


    const originalWarn = console.warn;
    console.warn = function (...args) {
      const warningMessage = args.join(' ');
      const warningEntry = `${new Date().toLocaleTimeString()} [WARNING] ${warningMessage}\n`;
      logContainer.textContent += warningEntry;
      scrollToBottom();
      originalWarn.apply(console, args);
    };

    const originalInfo = console.info;
        console.info = function (...args) {
          const warningMessage = args.join(' ');
          const warningEntry = `${new Date().toLocaleTimeString()} [INFO] ${warningMessage}\n`;
          logContainer.textContent += warningEntry;
          scrollToBottom();
          originalWarn.apply(console, args);
        };

    const originalLog = console.log;
    console.log = function (...args) {
      const logMessage = args.join(' ');
      const logEntry = `${new Date().toLocaleTimeString()} [LOG] ${logMessage}\n`;
      logContainer.textContent += logEntry;
      scrollToBottom();
      originalLog.apply(console, args);
    };
    const originalError = console.error;
    console.error = function (...args) {
      const errorMessage = args.join(' ');
      const errorEntry = `${new Date().toLocaleTimeString()} [ERROR] ${errorMessage}\n`;
      logContainer.textContent += errorEntry;
      scrollToBottom();
      originalError.apply(console, args);
    };
  })();

</script>
</body></html>